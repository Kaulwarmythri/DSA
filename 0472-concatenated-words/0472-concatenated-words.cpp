class Solution {
    struct TrieNode {
	    struct TrieNode* child[26];
	    bool end = false;
	    TrieNode() {
		    for(int i=0; i<26; i++) child[i] = NULL;
		    end = false;
	    }
    };

    TrieNode* root;

    void insert(string s){
        TrieNode* node = root;
        /* 
         * inserting the string in reverse order as we will search from the
         * end (i.e. suffix) of the word while using DP.
         */
        for(int i = s.size()-1; i >= 0; i--) {
            char ch = s[i];
            if(!node->child[ch-'a']) {
                node->child[ch-'a'] = new TrieNode();
            }
            node = node->child[ch-'a'];
        }
        node->end = true;
    }
public:
    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {
        /* 
         * every word can be generated by concatinating smaller words only,
         * so smaller words will be processed and inserted into trie first 
         */
        sort(words.begin(), words.end(), [](const string& w1, const string& w2) {
            return (w1.size() < w2.size());
        });
        
        vector<string> ans;
        root = new TrieNode();
        
        for(string &w : words) {
            if(w.size() == 0)
                continue;
            
            vector<bool> dp(w.size()+1, false); dp[0] = true;
            
            for(int i = 0; i < w.length(); i++) {
                TrieNode* node = root;
                for(int j = i; j >= 0; j--) {
                    if(node->child[w[j]-'a'] == NULL)
                        break;
                    
                    node = node->child[w[j]-'a'];
                    if(dp[j] && node->end) {
                        dp[i+1] = true;
                        break;
                    }
                }
            }
            
            if(dp[w.length()])
                ans.push_back(w);
            
            insert(w);
        }
        
        return ans;
    }
};